---
title: Using Local Anvil-ZKsync for L1-L2 Testing and Debugging
description: Learn how to deploy and test cross-chain interactions locally with Anvil-ZKsync, enabling realistic L1-L2 communication for rapid iteration and debugging.
---

## Prerequisites

- This tutorial uses Solidity. You should have some experience with the language.
- You must have [anvil](https://book.getfoundry.sh/getting-started/installation) installed.
- You must have [Foundry-ZKsync](https://foundry-book.zksync.io/getting-started/installation#using-foundryup-zksync) installed.

## What You Will Deploy

- An L1 contract (`AccessKey`) that sends cross-chain messages.
- An L2 contract (`Vault`) that responds to L1-initiated calls.

## Why Use L1-L2 Local Testing?

Local testing with Anvil-ZKsync offers a fast, controlled environment for developing and debugging cross-chain applications. It allows you to:

- Simulate L1-L2 interactions without the cost of public testnets.
- Debug system log production and protocol upgrade flows.

## Introduction to L1-L2 Anvil-ZKsync Environment

Anvil-ZKsync provides a local environment mimicing ZKsync's L1-L2 setup:

- **Local L1 with Anvil:** Anvil serves as your Ethereum-like L1 environment, fully supporting priority transactions and protocol upgrade flows.
- **Local L2 with Anvil-ZKsync:** L2 is replicated with a precomputed state and commitment values, which allows you to test L1-L2 message
passing and log generation.
- **Limitations:** The current setup does not support L1-L2 forking.

## How It Will Work

Here's the updated step-by-step "How it will work" section with the Anvil-ZKsync environment setup as step 1:

---

## How it will work

1. **Set Up the Anvil-ZKsync Environment:**  
   First, you'll spin up a local environment using Anvil-ZKsync that makes use of `anvil` as the L1.

2. **Deploy the AccessKey Contract on L1:**  
   With your local environment running, you will deploy a simple AccessKey contract on L1. This
  contract is responsible for sending cross-chain messages to L2.

3. **Deploy the Vault Contract on L2:**  
   Next, you'll deploy a Vault contract on the L2 side. This contract includes an `unlock()` function that can only be triggered by a valid
  L1-initiated message.

4. **Send an L1→L2 Message:**  
   Using a Foundry script, you'll send a cross-chain message from the AccessKey contract on L1. This message is routed via the Bridgehub and
  is intended to invoke the Vault contract’s `unlock()` function on L2.

5. **Prove Message Inclusion on L2:**  
   After sending the message, you will verify its inclusion in an L2 batch by calling a proof function (such as `proveL2MessageInclusion`).
  This step demonstrates how to generate and validate Merkle proofs for cross-chain messages.

6. **Debug and Validate:**  
   Finally, you will inspect gas estimations, system logs. This allows you to debug the transaction flow and confirm that all components interact as expected.
