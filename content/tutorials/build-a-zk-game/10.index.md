---
title: Build a ZK Game
description: Learn how to verify ZK proofs on chain by building a game.
---

## Prerequisites

- **You must have access to SP1's prover network.**
  At the time of writing, you must follow [these instructions](https://docs.succinct.xyz/docs/generating-proofs/prover-network) to gain access to the network.
- This tutorial uses TypeScript, Rust, and Solidity. You should have some experience with at least two of these languages.
- You must have [Node.js](https://nodejs.org/en/download) version `20` installed.
- You must have [Rust](https://www.rust-lang.org/tools/install) installed.
- You will need [Docker Desktop](https://www.docker.com/get-started/) installed to run a local node.

## What You Will Build

In this tutorial you will build a game that:

1. Lets users verify their high scores on chain using ZK proofs.
1. Integrates ZKsync SSO and a paymaster for seamless UX.

(TODO: add image)

## Why use ZK?

If have ever tried to build a game on chain,
you will know that there are some unique limitations.
For example, if you put every move in the game on chain, the game quickly becomes slow and expensive.
But without every move on chain, how can you verify the player's achievements in a permissionless way?

What if you could somehow let anyone prove their own final score on chain, without giving away how they achieved it on chain?
What if you could give players the option of saving their score on chain and skipping any onchain activity when they didn't get the score they wanted?

One way to accomplish this is by using ZK proofs.

## Introduction to ZK proofs

If you are new to ZK proofs, here is a very brief summary what you need to know:

- ZK stands for Zero Knowledge.
- ZK allows you to prove some information is correct without revealing all of the supporting evidence.
(On the other side, ZK allows you to verify some information is correct without knowing the underlying data.)
- There are two steps to using ZK: 1) creating proofs, and 2) verifying those proofs.
- When creating proofs, there are private inputs (e.g. the supporting evidence) and public outputs (e.g. the provable information).
- There is no way to decode the private inputs from the proof or public outputs.
- A proof and its public outputs can be verified on chain using a verifier contract.

## How it will work

The game will record the player's movements in the game.
We will use a re-creation of a popular game known as "Breakout" or "Brickles".

When the player decides to save their high score on chain,
the game will send the recorded actions and final score and time to a backend service to generate a proof.

On the backend, the game will be re-run using those recorded actions inside an SP1 program.
In the game contract, we will make sure that this exact program is being run using a program verification key.
With this, we are able to create a proof that the recorded actions indeed produce the same score and time that the player claims.

The API will then use SP1 to create a proof of the player's final score and time.

::centered-container

![zk-game-flow-chart](/images/zk-game-flow-chart.png)

::

One condition of this method is that the game must be deterministic.
This means that for given player inputs, it will always result in the same score.
The game itself is all written in Rust, so the exact same game code is running in the client and the backend.

Finally once the API returns the proof data, the player can verify the score on chain using their SSO account.
The transaction will be sponsored with a paymaster contract so they don't need to have any funds to play.

In the next section, we will get started with the on chain contracts.
