---
title: Testing L1-L2 transactions using Anvil-ZKsync 
description: Learn how to build and deploy L1 and L2 contracts, test them locally, and initiate cross-chain transactions using the latest anvil-zksync features  

---

### **Setting Up Your Project**  

In this guide, we will set up a **local L1-L2 environment** using `anvil-zksync`, then create and deploy an **L1** contract (`AccessKey`)
and an **L2** contract (`Vault`). By the end of this
section, you will have a development environment ready for **contract development, testing, and deployment** on ZKsync.

## **1. Setting Up the L1-L2 Local Environment**

`anvil-zksync` is included with Foundry-ZKsync and provides a local environment
for testing L1-L2 contract interactions on ZKsync. You have two main ways to start the local network:

1. **Spawn a Local L1 Node**

   ```bash
   anvil-zksync --spawn-l1
   # or specify a port:
   anvil-zksync --spawn-l1 9000
   ```

   - This command launches a local L2 node along with an embedded local L1 node.  
   - By default, the L1 node runs on port **8012** unless you specify another port.

2. **Connect to an External L1 Node**  
   - Start your own Anvil L1 node with unlimited request size:

     ```bash
     anvil --no-request-size-limit
     ```

   - Then run `anvil-zksync` pointing to that L1 node:

     ```bash
     anvil-zksync --external-l1 http://localhost:8545
     ```

   - Note that the `--spawn-l1` and `--external-l1` flags are **mutually exclusive**; you can only use one at a time.

### **Starting the Local Node**

A quick way to get started is simply:

```bash
anvil-zksync -vv --spawn-l1
```

- **`-vv`**: Enables user EraVM logs, which can be helpful for debugging.  
- **`--spawn-l1`**: Spawns a local L1 node alongside the L2 environment.

When you run this command, youâ€™ll see logs indicating your local L2 node is running, along with a list of prefunded accounts
(e.g., addresses with 10,000 ETH). You can use these accounts to deploy contracts and make transactions **without** using real funds.

With this local environment set up, you are ready to build, deploy, and test your L1-L2 contracts!

## **Project Initialization**  

To get started, **clone the template repository** into a new project folder called `l1-l2-template`:  

```sh
git clone git@github.com:dutterbutter/l1-l2-template.git
l1-l2-template
```

This template includes the **basic Foundry setup** needed to begin development. Hereâ€™s what youâ€™ll find inside:  

### **Whatâ€™s Missing?**  

The template does not yet include:  

âœ… L1-L2 Interaction script

Weâ€™ll add these components within this tutorial.  

## **Installing Dependencies**  

To implement initiate L1-L2 transactions, we need a access to the Bridgehub contract:  

- **`@zksync-contracts`** â€“ Provides interfaces for interacting with ZKsync-specific smart contracts.

### **Installing Dependencies with Soldeer**  

For dependency management, we will use [Soldeer](https://soldeer.xyz/), a **dedicated Solidity package manager**. If you
prefer, you can install dependencies via Git submodules using `forge install matter-labs/v2-testnet-contracts@beta`.

However, for this guide, we will use **Soldeer** to install our required packages:

```sh
cd l1-l2-template
forge soldeer install
```

### **What This Command Does:**  

- Creates a `dependencies/` folder to store the installed packages.  
- Installs `@zksync-contracts`, and `forge-zksync-std`.  
- Generates a `remappings.txt` file for clean import paths, simplifying contract development.  

With our project set up and dependencies installed, we are now ready to **deploy our contracts on our local environment**! ðŸš€

### Contract Code

Next, letâ€™s review our L1AccessKey contract called L1AccessKey.sol in the l1-access directory. This contract
demonstrates how to send transactions from L1 to L2 (for example, to unlock a vault on zkSync's L2) by interacting with the Bridgehub contract.

::drop-panel
::panel{label="L1AccessKey.sol"}

```solidity [l1-access/src/L1AccessKey.sol]
:code-import{filePath="l1-l2-tutorial/l1-access/src/L1AccessKey.sol"}
```

::
::

### Understanding the `L1AccessKey` Contract  

Let's break down the `L1AccessKey` contract and explain how it works.  

### **Contract Overview**

The L1AccessKey contract is designed to:

1. Store an owner address on L1.
2. Allow only that owner to initiate a cross-chain transaction to L2.
3. Use `IBridgehub` interface to send a direct transaction request to an L2 contract.

## **Key Components**  

1. `owner`: Stores the address of the account (or contract) that deployed and manages access to this contract.
2. `constructor()`: Sets the deploying account as the owner.
3. `unlockVaultOnL2(...)`: The primary function that uses `Bridgehub` to send a transaction to L2.

### **Functions**  

#### `unlockVaultOnL2`  

```solidity
function unlockVaultOnL2(
    uint256 chainId,
    address bridgeHubAddress,
    address vaultAddress,
    bytes memory data,
    uint256 gasLimit,
    uint256 gasPerPubdataByteLimit,
    uint256 cost
) external payable {
```

**How it works:**  

1. **Ownership Check:** Ensures only the contract owner can initiate L2 calls.
2. **Create a Bridgehub Instance:** We instantiate `IBridgehub` using the address passed in.
3. **Construct L2 Transaction:** We build an `L2TransactionRequestDirect` struct, specifying all the details
needed for the L2 call (destination L2 contract, calldata, gas limits, etc.).
4. **Send the Transaction:** We call `bridgeHub.requestL2TransactionDirect` and provide `msg.value` as ETH to pay for bridging costs on L2.

> Note: `msg.value` (the native tokens sent with the transaction) is forwarded to `requestL2TransactionDirect`,
covering the cost of sending this transaction cross-chain.

## Deploying Contracts

Letâ€™s review the `DeployAccessKey.s.sol` deployment script in the `script/` directory. This script shows how to
deploy our L1 contract so it can be used to trigger L2 calls via `Bridgehub`.

```solidity [script/DeployAccessKey.s.sol]
:code-import{filePath="l1-l2-tutorial/l1-access/script/DeployAccessKey.s.sol"}
```

### Understanding the `DeployAccessKey.s.sol` Deployment Script

This script uses Foundryâ€™s Script functionality to broadcast transactions to the network and deploy the `AccessKey` contract (our L1AccessKey in practice).

#### **Deploy**  

```solidity
AccessKey accessKey = new AccessKey();
console2.log("AccessKey deployed at:", address(accessKey));
```

- **Purpose:** Instantiates and deploys our `AccessKey` contract to the L1 network.
- **Result:** Outputs the deployed contractâ€™s address, which we can then use for cross-chain interactions.

### **Deploying to Local Anvil-Zksync Instance**

With the local node running, navigate to the `l1-access/` directory to deploy your **L1** contract, `AccessKey.sol`, using the provided deployment
script in `script/`.

```bash
forge script script/DeployAccessKey.s.sol:DeployAccessKey \
  --rpc-url anvil-zksync-l1 \
  --broadcast \
  --interactive 1
```

**This script will**:

1. Deploy the `AccessKey` contract to the **spawned L1 node** (default port **8012** if using `--spawn-l1`).

After running the script, youâ€™ll be prompted to enter a private key. Use one of the prefunded keys displayed when you launched `anvil-zksync`:

```bash
Enter private key: 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
```

#### **Successful Script Execution Output**

If the deployment is successful, you should see output similar to:

```bash
âœ…  [Success] Hash: 0x06ed287a74d0adb673f05d1947bf4a1be95b7c58dbffebb3f8263b777ed50fd2
Contract Address: 0x700b6A60ce7EaaEA56F065753d8dcB9653dbAD35
Block: 87
Paid: 0.001609861554230312 ETH (536687 gas * 2.999628376 gwei)
```

**Make sure to copy this newly deployed `AccessKey` contract address**, as weâ€™ll need it to deploy our L2 Vault contract next.

---

### **Deploying the L2 Vault**

After deploying your **AccessKey** contract on L1, **copy its address**. Then open `l2-vault/script/DeployVault.s.sol` and update the following line
with your newly deployed address:

```solidity
address l1AccessKey = 0x700b6A60ce7EaaEA56F065753d8dcB9653dbAD35;
```

With that done, navigate to the `l2-vault` directory and execute:

```bash
forge script script/DeployVault.s.sol:DeployVault \
  --rpc-url anvil-zksync-l2 \
  --broadcast \
  --interactive 1
```

**This script will**:

1. **Deploy** the `Vault` contract to the **running L2 node**.  
2. Prompt you for a private key; use one of the prefunded keys from your `anvil-zksync` session.

```bash
Enter private key: 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
```

#### **Successful Script Execution Output**

If the deployment is successful, you should see:

```bash
##### 260
âœ…  [Success] Hash: 0xeb449568fa013508041294de83ac4cf3b246629ab41648bbaadd4d5fa232b764
Contract Address: 0xF9099bBDcc3Dd9d3DcBe1Be3d60883e6F630c3ca
Block: 5
Paid: 0.00012705046125 ETH (2807745 gas * 0.04525 gwei)

âœ… Sequence #1 on 260 | Total Paid: 0.00012705046125 ETH (2807745 gas * avg 0.04525 gwei)
```

Congratulations! You now have:

- `AccessKey` deployed on our local L1 node
- `Vault` deploy on on our local L2 node

Next, letâ€™s interact with the L2 contract from L1.

---

### **Next Steps: Interacting with the L2 Contract from L1**

Now that we have deployed both the **AccessKey** contract on **L1** and the **Vault** contract on **L2**, the next step is to demonstrate how
**we can interact** with the L2 contract from L1 by calling `unlockVaultOnL2(...)`. Weâ€™ll walk through how to:

- **Call L2 contract from L1** and supply the correct parameters.
- **Review the anvil-zksync logs** to showcase what is happening.
