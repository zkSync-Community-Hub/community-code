---
title: Testing the frontend
description: Test running the frontend for the interop DeFi app.
---

The frontend has most of what we need to run it, but is just missing a few details.
Let's add them!

## Constants

Move into the frontend folder and create a new file in the `src/config` folder called `constants.ts`:

```bash
cd frontend
touch src/config/constants.ts
```

Copy and paste the code below:

```ts [src/config/constants.ts]
:code-import{filePath="interop-messages/frontend/config/constants.ts"}
```

Update the contract addresses with your deployed contract addresses.

## Wagmi config

In the `src/config/wagmi.ts` file, double check that the RPC endpoints and chain IDs for match your local chains.

If you forgot these, you can find them in your `interop_ecosystem` folder.
The chain ID can be found in the `chains/<CHAIN_NAME>/ZkStack.yaml` file,
and the endpint in the `chains/<CHAIN_NAME>/configs/general.yaml` file under `api.web3_json_rpc.http_url`.

## Interop utils

Create a new folder called `utils` in the `src` folder.

```bash
mkdir src/utils
```

Then create a file called `prove.ts` in that folder:

```bash
touch src/utils/prove.ts
```

This is where we will implement the logic for fetching the input arguments for the `mint` function,
and making sure an interop message is ready to be verified.

Once the user deposits some ETH to a staking contract,
they will be able to submit their transaction hash to a "Mint" form on the rewards chain,
and we can use the transaction hash to fetch the required input arguments for onchain message verification.

Before the message can be verified, though,
the transaction must be finalized,
and the interop roots on gateway and the rewards chain must be updated.
We will add some functions below to check these statuses, and fetch the input arguments for minting.

Copy and paste the functions below:

```ts [src/utils/prove.ts]
:code-import{filePath="interop-messages/frontend/utils/prove.ts"}
```

There are three functions we've just added:

1. `checkIfTxIsFinalized`: This function checks to see if the deposit transaction has finalized.
  Locally, this will take just a few minutes.
  However on a live testnet or mainnet, this will take three hours, as that is currently the required time set by the ZKsync governance.
1. `updateLocalChainInteropRoot`: This function does a couple things.
  First, it uses the local pre-configured wallet we used for deploying contracts to send transactions on the rewards chain
  in order to seal the next batch of blocks.
  This is needed only on a local ecosystem, as there would otherwise not be any other transactions to create new blocks.
  Second, it fetches the interop root on gateway to check if it has been updated based on the deposit transaction yet.
  For testnet and mainnet chains, you can instead use the `waitForGatewayInteropRoot` util function from `zksync-ethers` to check this.
1. `getProveScoreArgs`: This function takes the transaction hash input by the user in the "Mint" form
  and fetches the needed arguments to verify the message sent in the `deposit` function.

## Handling Verification

The last change we need to make is updating the `handleSubmit` function
in the `MintForm` component.

The full flow for minting the token looks like this:

1. The user inputs the transaction hash from their deposit transaction, and selects which staking chain they used.
1. The appropriate staking contract address is fetched from our constants file.
1. The `handleSubmit` function waits until the transaction is finalized.
1. The `handleSubmit` function waits until the interop root on gateway is updated.
1. The `handleSubmit` function fetches the input arguments for the `mint` function.
1. The user is prompted to approve calling the `mint` function with their wallet.
1. The transaction gets approved, and the leaderboard table gets updated with the latest number of mints per chain.

In `components/MintForm.tsx`, update the `handleSubmit` function with the completed function below:

```ts [src/components/MintForm.tsx]
:code-import{filePath="interop-messages/frontend/components/MintForm.tsx:submit"}
```

## Run the app

Use the command below to run the frontend.

::code-group

```bash [npm]
npm run dev
```

```bash [yarn]
yarn dev
```

```bash [pnpm]
pnpm dev
```

```bash [bun]
bun dev
```

::

You can now open the frontend at [`http://localhost:5173/`](http://localhost:5173/).

On the frontend, you should be able to add each network to your wallet by clicking on them from the dropdown menu.

You can send funds to your wallet using the `zkstack dev rich-account` command:

```bash
zkstack dev rich-account --chain zk_chain_1 0x<YOUR_WALLET_ADDRESS>
```

```bash
zkstack dev rich-account --chain zk_chain_2 0x<YOUR_WALLET_ADDRESS>
```

```bash
zkstack dev rich-account --chain zk_chain_3 0x<YOUR_WALLET_ADDRESS>
```

Now you can test the staking and tokens contracts with the frontend!

On one of the staking chains, deposit any amount of ETH and then copy your transaction hash.
On the rewards chain, input the transaction hash and select the staking chain you used.
Then click the mint button to mint a reward token.

This process will take a few minutes on a local ecosystem.
If you are trying this out on a live testnet,
wait until your deposit transaction is finalized on the block explorer before trying to mint.
Once minted, you should see the leaderboard table update.

::twitter-button{text="I just built a crosschain DeFi app with @zkSyncDevs"}
